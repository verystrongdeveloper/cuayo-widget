<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Speaki Widget</title>
  <style>
    * {
      box-sizing: border-box;
    }

    html,
    body {
      margin: 0;
      width: 100%;
      height: 100%;
      background: transparent;
      overflow: hidden;
      font-family: "Segoe UI", "Apple SD Gothic Neo", "Malgun Gothic", sans-serif;
    }

    .stage {
      position: relative;
      width: 100vw;
      height: 100vh;
    }

    .guide {
      position: fixed;
      top: 12px;
      left: 12px;
      padding: 8px 12px;
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.9);
      color: #1f2937;
      font-size: 12px;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.16);
      z-index: 20;
      user-select: none;
    }

    .settings-panel {
      position: fixed;
      min-width: 190px;
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(17, 24, 39, 0.15);
      background: rgba(255, 255, 255, 0.96);
      box-shadow: 0 14px 30px rgba(0, 0, 0, 0.2);
      z-index: 30;
      user-select: none;
    }

    .settings-title {
      margin: 0 0 8px;
      color: #111827;
      font-size: 13px;
      font-weight: 700;
    }

    .settings-actions {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .settings-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      color: #111827;
      font-size: 12px;
      font-weight: 600;
    }

    .settings-value {
      font-variant-numeric: tabular-nums;
      color: #374151;
      font-size: 12px;
      font-weight: 700;
    }

    .settings-range {
      width: 100%;
      accent-color: #4f46e5;
    }

    .settings-button {
      width: 100%;
      border: 0;
      border-radius: 8px;
      padding: 8px 10px;
      font-size: 12px;
      text-align: left;
      color: #111827;
      background: #eef2ff;
      cursor: pointer;
    }

    .settings-button:hover {
      background: #e0e7ff;
    }

    .settings-button.secondary {
      background: #f3f4f6;
    }

    .settings-button.secondary:hover {
      background: #e5e7eb;
    }

    .desktop-widget-mode .guide {
      display: none;
    }

    .desktop-widget-mode .speaki-widget {
      left: 50%;
      top: 50%;
      right: auto;
      bottom: auto;
      width: min(320px, calc(100vw - 16px));
      transform: translate(-50%, -50%);
    }

    .speaki-widget {
      position: absolute;
      right: 8px;
      bottom: 8px;
      width: min(280px, calc(100vw - 16px));
      z-index: 10;
      user-select: none;
      -webkit-user-drag: none;
      touch-action: none;
      cursor: grab;
      animation: show-up 0.45s ease-out;
    }

    .speaki-widget::before {
      content: none;
    }

    .speaki-widget.dragging {
      cursor: grabbing;
    }

    .speaki-widget img {
      display: block;
      width: 100%;
      height: auto;
      pointer-events: none;
      position: relative;
      z-index: 1;
      transform-origin: center;
      transition: transform 120ms linear;
    }

    .speaki-widget.dragging img {
      transition: none;
      animation: drag-flail-right 150ms ease-in-out infinite;
    }

    .speaki-widget.dragging.facing-left img {
      animation-name: drag-flail-left;
    }

    .speaki-widget.facing-left img {
      transform: scaleX(-1);
    }

    .speaki-widget.sprite-failed {
      width: 220px;
      height: 220px;
      border-radius: 999px;
      border: 2px solid rgba(251, 113, 133, 0.9);
      background: linear-gradient(145deg, rgba(255, 228, 234, 0.96), rgba(255, 244, 246, 0.96));
      box-shadow: 0 10px 22px rgba(190, 24, 93, 0.2);
    }

    .speaki-widget.sprite-failed img {
      display: none;
    }

    .speaki-widget.exiting {
      animation: dissolve-away 760ms cubic-bezier(0.22, 1, 0.36, 1) forwards;
      pointer-events: none;
    }

    .speaki-widget.exiting img {
      animation: character-spin-shrink-away 760ms cubic-bezier(0.15, 0.9, 0.2, 1) forwards;
    }

    .browser-draggable {
      position: fixed;
      left: 0;
      top: 0;
      right: auto;
      bottom: auto;
    }

    @keyframes show-up {
      from {
        opacity: 0;
        transform: translateY(10px) scale(0.97);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    @keyframes drag-flail-right {
      0% {
        transform: translateY(0) rotate(0deg);
      }
      25% {
        transform: translateY(-3px) rotate(-9deg);
      }
      50% {
        transform: translateY(2px) rotate(8deg);
      }
      75% {
        transform: translateY(-2px) rotate(-8deg);
      }
      100% {
        transform: translateY(0) rotate(0deg);
      }
    }

    @keyframes drag-flail-left {
      0% {
        transform: scaleX(-1) translateY(0) rotate(0deg);
      }
      25% {
        transform: scaleX(-1) translateY(-3px) rotate(9deg);
      }
      50% {
        transform: scaleX(-1) translateY(2px) rotate(-8deg);
      }
      75% {
        transform: scaleX(-1) translateY(-2px) rotate(8deg);
      }
      100% {
        transform: scaleX(-1) translateY(0) rotate(0deg);
      }
    }

    @keyframes dissolve-away {
      0% {
        opacity: 1;
      }
      100% {
        opacity: 0;
      }
    }

    @keyframes character-spin-shrink-away {
      0% {
        opacity: 1;
        transform: rotate(0deg) scale(1);
        filter: blur(0);
      }
      20% {
        opacity: 1;
        transform: rotate(720deg) scale(0.95);
      }
      55% {
        opacity: 0.88;
        transform: rotate(1800deg) scale(0.45);
      }
      100% {
        opacity: 0;
        transform: rotate(2880deg) scale(0.015);
        filter: blur(6px);
      }
    }
  </style>
</head>
<body>
  <main id="stage" class="stage">
    <div class="guide">Click Speaki: next mood + voice. Right-click: open settings.</div>
    <div id="speakiWidget" class="speaki-widget" aria-label="Speaki widget">
      <img src="./images/speaki_smile.png" alt="Speaki character" draggable="false" />
    </div>
    <div id="settingsPanel" class="settings-panel" role="dialog" aria-label="Speaki settings" aria-hidden="true" hidden>
      <p class="settings-title">Speaki Settings</p>
      <div class="settings-actions">
        <div class="settings-row">
          <span>Character size</span>
          <span id="settingsSizeValue" class="settings-value">280px</span>
        </div>
        <input id="settingsSizeRange" class="settings-range" type="range" min="140" max="420" step="10" value="280" />
        <button id="settingsPumpkinButton" type="button" class="settings-button">Pumpkin</button>
        <button id="settingsExitButton" type="button" class="settings-button secondary">Exit</button>
      </div>
    </div>
  </main>

  <script>
    (function () {
      const stage = document.getElementById("stage");
      const widget = document.getElementById("speakiWidget");
      const sprite = widget.querySelector("img");
      const guide = document.querySelector(".guide");
      const settingsPanel = document.getElementById("settingsPanel");
      const settingsSizeRange = document.getElementById("settingsSizeRange");
      const settingsSizeValue = document.getElementById("settingsSizeValue");
      const settingsPumpkinButton = document.getElementById("settingsPumpkinButton");
      const settingsExitButton = document.getElementById("settingsExitButton");
      const storageKey = "speaki-widget-position-v1";
      const sizeStorageKey = "speaki-widget-size-v1";
      const margin = 8;
      const isTauriDesktop = Boolean(window.__TAURI_INTERNALS__);
      const defaultWidgetWidth = isTauriDesktop ? 320 : 280;
      const minWidgetWidth = 140;
      const maxWidgetWidth = isTauriDesktop ? 320 : 420;
      const expressions = [
        {
          id: "smile",
          label: "Smile",
          sprite: "speaki_smile.png",
          voices: ["like.WAV", "like2.WAV", "like3.WAV", "speeky.WAV"]
        },
        {
          id: "smile2",
          label: "Happy",
          sprite: "speaki_smile2.png",
          voices: ["like2.WAV", "like3.WAV", "clean.WAV"]
        },
        {
          id: "eating",
          label: "Eating",
          sprite: "speaki_eating.png",
          voices: ["I like pumpkin.WAV", "clean.WAV"]
        },
        {
          id: "back",
          label: "Back",
          sprite: "speaki_back.png",
          voices: ["kakurenbo.WAV", "speeky.WAV"]
        },
        {
          id: "crying",
          label: "Crying",
          sprite: "speaki_crying.png",
          voices: ["eww.WAV", "eww2.WAV", "don't push.WAV"]
        },
        {
          id: "crying2",
          label: "Sad",
          sprite: "speaki_crying2.png",
          voices: ["eww2.WAV", "don't push.WAV"]
        },
        {
          id: "crying3",
          label: "Tired",
          sprite: "speaki_crying3.png",
          voices: ["eww.WAV", "clean.WAV"]
        }
      ];
      const state = {
        dragging: false,
        pointerId: null,
        dragOffsetX: 0,
        dragOffsetY: 0,
        dragExpressionIndex: null,
        startX: 0,
        startY: 0,
        moved: false,
        suppressClickUntil: 0,
        desktopAutoMoveLockUntil: 0,
        desktopPointerDown: false,
        desktopStartScreenX: 0,
        desktopStartScreenY: 0,
        desktopWindowStartX: 0,
        desktopWindowStartY: 0,
        desktopWindowReady: false,
        desktopMoveQueued: false,
        desktopTargetX: null,
        desktopTargetY: null,
        desktopDragArmed: false,
        desktopDragHoldTimer: null,
        settingsOpen: false,
        exiting: false,
        sulking: false
      };
      let expressionIndex = 0;
      let activeAudio = null;
      let dragFlipTimer = null;
      let desktopFacingTrackTimer = null;
      let desktopLastWindowX = null;
      const desktopDragHoldMs = 260;
      const forcedDragExpressionIndex = expressions.findIndex(function (expression) {
        return expression.id === "crying";
      });
      const smileExpressionIndex = expressions.findIndex(function (expression) {
        return expression.id === "smile2";
      });
      const dragVoices = ["eww.WAV", "eww2.WAV"];

      function assetPath(folder, fileName) {
        return "./" + folder + "/" + encodeURIComponent(fileName);
      }

      function invokeTauri(commandName, payload) {
        if (!window.__TAURI_INTERNALS__ || typeof window.__TAURI_INTERNALS__.invoke !== "function") {
          return Promise.reject(new Error("Tauri invoke is unavailable"));
        }
        return window.__TAURI_INTERNALS__.invoke(commandName, payload || {});
      }

      function setGuide(text) {
        if (guide) {
          guide.textContent = text;
        }
      }

      function clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }

      function wait(ms) {
        return new Promise(function (resolve) {
          window.setTimeout(resolve, ms);
        });
      }

      function stopDesktopFacingTracking() {
        if (desktopFacingTrackTimer !== null) {
          window.clearInterval(desktopFacingTrackTimer);
          desktopFacingTrackTimer = null;
        }
        desktopLastWindowX = null;
      }

      function startDesktopFacingTracking() {
        if (!isTauriDesktop) {
          return;
        }

        stopDesktopFacingTracking();
        let pollBusy = false;

        invokeTauri("get_window_geometry")
          .then(function (geometry) {
            if (geometry && Number.isFinite(geometry.x)) {
              desktopLastWindowX = geometry.x;
            }
          })
          .catch(function () {
            // Ignore initial geometry failure.
          });

        desktopFacingTrackTimer = window.setInterval(function () {
          if (pollBusy || state.exiting || state.dragging || state.desktopPointerDown || widget.classList.contains("dragging")) {
            return;
          }

          pollBusy = true;
          invokeTauri("get_window_geometry")
            .then(function (geometry) {
              if (!geometry || !Number.isFinite(geometry.x)) {
                return;
              }

              const currentX = geometry.x;
              if (desktopLastWindowX === null) {
                desktopLastWindowX = currentX;
                return;
              }

              const deltaX = currentX - desktopLastWindowX;
              desktopLastWindowX = currentX;
              if (Math.abs(deltaX) >= 1) {
                setFacingByDelta(deltaX);
              }
            })
            .catch(function () {
              // Ignore intermittent geometry failures.
            })
            .finally(function () {
              pollBusy = false;
            });
        }, 90);
      }

      function setFacingByDelta(deltaX) {
        if (widget.classList.contains("dragging")) {
          return;
        }

        if (deltaX < -1) {
          widget.classList.add("facing-left");
          return;
        }
        if (deltaX > 1) {
          widget.classList.remove("facing-left");
        }
      }

      function stopDragFlipFrenzy() {
        if (dragFlipTimer !== null) {
          window.clearTimeout(dragFlipTimer);
          dragFlipTimer = null;
        }
      }

      function startDragFlipFrenzy() {
        stopDragFlipFrenzy();

        (function flipLoop() {
          if (!widget.classList.contains("dragging") || state.exiting) {
            stopDragFlipFrenzy();
            return;
          }

          widget.classList.toggle("facing-left");
          const nextDelay = Math.round(58 + Math.random() * 56);
          dragFlipTimer = window.setTimeout(flipLoop, nextDelay);
        })();
      }

      function randomItem(items) {
        return items[Math.floor(Math.random() * items.length)];
      }

      function stopAudio() {
        if (!activeAudio) {
          return;
        }

        activeAudio.pause();
        activeAudio.currentTime = 0;
        activeAudio = null;
      }

      function playVoice(fileName) {
        if (!fileName) {
          return;
        }

        stopAudio();
        activeAudio = new Audio(assetPath("voice", fileName));
        activeAudio.volume = 0.9;
        activeAudio.play().catch(function () {
          setGuide("Audio blocked by system. Click Speaki again.");
        });
      }

      function playDragVoice() {
        playVoice(randomItem(dragVoices));
      }

      function playExitVoice() {
        playVoice("eww.WAV");
      }

      function onPumpkinTimeout() {
        clearDesktopDragHoldTimer();
        state.dragging = false;
        state.desktopPointerDown = false;
        state.desktopDragArmed = false;
        state.sulking = true;
        setDraggingVisual(false);
        if (forcedDragExpressionIndex >= 0) {
          setExpression(forcedDragExpressionIndex, false);
        }
        playVoice(randomItem(dragVoices));
        setGuide("Pumpkin miss... Speaki is crying.");
      }

      function startPumpkinEventPolling() {
        if (!isTauriDesktop) {
          return;
        }

        let pollBusy = false;
        window.setInterval(function () {
          if (state.exiting || pollBusy) {
            return;
          }

          pollBusy = true;
          invokeTauri("take_pumpkin_timeout_flag")
            .then(function (isTimedOut) {
              if (isTimedOut) {
                onPumpkinTimeout();
                return false;
              }
              return invokeTauri("take_pumpkin_eaten_flag");
            })
            .then(function (isEaten) {
              if (isEaten) {
                state.desktopAutoMoveLockUntil = Date.now() + 120;
                if (state.sulking) {
                  state.sulking = false;
                  setExpression(smileExpressionIndex >= 0 ? smileExpressionIndex : 0, false);
                  playVoice("like3.WAV");
                } else {
                  playVoice("I like pumpkin.WAV");
                }
                moveDesktopWindowRandomX().catch(function () {
                  // Ignore movement failures and let wander loop continue.
                });
              }
            })
            .catch(function () {
              // Ignore intermittent invoke failures.
            })
            .finally(function () {
              pollBusy = false;
            });
        }, 120);
      }

      function clearDesktopDragHoldTimer() {
        if (state.desktopDragHoldTimer !== null) {
          window.clearTimeout(state.desktopDragHoldTimer);
          state.desktopDragHoldTimer = null;
        }
      }

      function waitForAnimationEnd(element, timeoutMs) {
        return new Promise(function (resolve) {
          if (!element) {
            resolve();
            return;
          }

          let settled = false;
          function done() {
            if (settled) {
              return;
            }
            settled = true;
            element.removeEventListener("animationend", onEnd);
            resolve();
          }

          function onEnd(event) {
            if (event.target === element) {
              done();
            }
          }

          element.addEventListener("animationend", onEnd);
          window.setTimeout(done, timeoutMs);
        });
      }

      function setExpression(nextIndex, shouldPlayVoice) {
        expressionIndex = (nextIndex + expressions.length) % expressions.length;
        const expression = expressions[expressionIndex];
        sprite.src = assetPath("images", expression.sprite);
        sprite.alt = "Speaki " + expression.label;

        if (shouldPlayVoice) {
          playVoice(randomItem(expression.voices));
        }
      }

      function nextExpression(shouldPlayVoice) {
        setExpression(expressionIndex + 1, shouldPlayVoice);
      }

      function currentWidgetWidth() {
        const styledWidth = parseFloat(widget.style.width);
        if (Number.isFinite(styledWidth) && styledWidth > 0) {
          return styledWidth;
        }

        const rect = widget.getBoundingClientRect();
        return rect.width > 0 ? rect.width : defaultWidgetWidth;
      }

      function widgetSizeBounds() {
        const viewportMax = Math.max(minWidgetWidth, Math.floor(window.innerWidth - margin * 2));
        return {
          min: minWidgetWidth,
          max: Math.max(minWidgetWidth, Math.min(maxWidgetWidth, viewportMax))
        };
      }

      function updateSizeControl(width) {
        if (!settingsSizeRange || !settingsSizeValue) {
          return;
        }

        const sizeBounds = widgetSizeBounds();
        const safeWidth = clamp(Math.round(width), sizeBounds.min, sizeBounds.max);
        settingsSizeRange.min = String(sizeBounds.min);
        settingsSizeRange.max = String(sizeBounds.max);
        settingsSizeRange.value = String(safeWidth);
        settingsSizeValue.textContent = safeWidth + "px";
      }

      function applyWidgetSize(rawWidth, options) {
        const opts = options || {};
        const sizeBounds = widgetSizeBounds();
        const safeWidth = clamp(Math.round(rawWidth), sizeBounds.min, sizeBounds.max);
        widget.style.width = safeWidth + "px";
        updateSizeControl(safeWidth);

        if (opts.persistSize) {
          localStorage.setItem(sizeStorageKey, String(safeWidth));
        }

        if (opts.adjustPosition && !isTauriDesktop) {
          const pos = currentPosition();
          setPosition(pos.x, pos.y);
          if (opts.persistPosition) {
            savePosition();
          }
        }
      }

      function loadWidgetSize() {
        let nextWidth = defaultWidgetWidth;

        try {
          const raw = localStorage.getItem(sizeStorageKey);
          if (raw !== null) {
            const parsed = Number(raw);
            if (Number.isFinite(parsed) && parsed > 0) {
              nextWidth = parsed;
            }
          }
        } catch (_error) {
          nextWidth = defaultWidgetWidth;
        }

        applyWidgetSize(nextWidth, {
          persistSize: false,
          adjustPosition: false
        });
      }

      function closeSettingsPanel() {
        if (!settingsPanel || settingsPanel.hidden) {
          return;
        }
        settingsPanel.hidden = true;
        settingsPanel.setAttribute("aria-hidden", "true");
        state.settingsOpen = false;
      }

      function openSettingsPanel(clientX, clientY) {
        if (!settingsPanel || state.exiting) {
          return;
        }

        settingsPanel.hidden = false;
        settingsPanel.setAttribute("aria-hidden", "false");

        const rect = settingsPanel.getBoundingClientRect();
        const preferredX = typeof clientX === "number" ? clientX + 8 : margin;
        const preferredY = typeof clientY === "number" ? clientY + 8 : margin;
        const safeX = clamp(
          preferredX,
          margin,
          Math.max(margin, window.innerWidth - rect.width - margin)
        );
        const safeY = clamp(
          preferredY,
          margin,
          Math.max(margin, window.innerHeight - rect.height - margin)
        );

        settingsPanel.style.left = safeX + "px";
        settingsPanel.style.top = safeY + "px";
        updateSizeControl(currentWidgetWidth());
        state.settingsOpen = true;
      }

      async function exitApp() {
        if (isTauriDesktop) {
          try {
            await invokeTauri("exit_app");
            return;
          } catch (_error) {
            setGuide("Exit failed. Please close manually.");
          }
        }

        try {
          window.close();
        } catch (_error) {
          setGuide("This browser blocked closing the window.");
        }
      }

      async function runExitSequence() {
        if (state.exiting) {
          return;
        }

        state.exiting = true;
        stopDesktopFacingTracking();
        state.settingsOpen = false;
        closeSettingsPanel();
        clearDesktopDragHoldTimer();
        if (state.pointerId !== null && widget.hasPointerCapture(state.pointerId)) {
          widget.releasePointerCapture(state.pointerId);
        }
        state.dragging = false;
        state.pointerId = null;
        state.desktopPointerDown = false;
        state.desktopDragArmed = false;
        state.desktopTargetX = null;
        state.desktopTargetY = null;
        state.desktopAutoMoveLockUntil = Number.MAX_SAFE_INTEGER;
        setDraggingVisual(false);
        setGuide("Exit...");
        setExpression(forcedDragExpressionIndex >= 0 ? forcedDragExpressionIndex : 0, false);
        playExitVoice();
        await wait(520);
        widget.classList.add("exiting");
        await waitForAnimationEnd(widget, 1000);
        await exitApp();
      }

      function queueDesktopWindowMove(x, y) {
        state.desktopTargetX = x;
        state.desktopTargetY = y;

        if (state.desktopMoveQueued) {
          return;
        }

        state.desktopMoveQueued = true;
        (async function flushDesktopWindowMove() {
          while (state.desktopTargetX !== null && state.desktopTargetY !== null) {
            const targetX = state.desktopTargetX;
            const targetY = state.desktopTargetY;
            state.desktopTargetX = null;
            state.desktopTargetY = null;

            try {
              await invokeTauri("set_window_position", { x: targetX, y: targetY });
            } catch (_error) {
              break;
            }
          }

          state.desktopMoveQueued = false;
        })();
      }

      function setDraggingVisual(isDragging) {
        if (isDragging) {
          widget.classList.add("dragging");
          startDragFlipFrenzy();
          if (state.dragExpressionIndex === null) {
            state.dragExpressionIndex = expressionIndex;
          }
          if (
            forcedDragExpressionIndex >= 0 &&
            expressionIndex !== forcedDragExpressionIndex
          ) {
            setExpression(forcedDragExpressionIndex, false);
          }
          return;
        }

        widget.classList.remove("dragging");
        stopDragFlipFrenzy();
        if (state.dragExpressionIndex !== null) {
          setExpression(state.dragExpressionIndex, false);
          state.dragExpressionIndex = null;
        }
      }

      function finishDesktopDrag(pointerId) {
        if (pointerId !== undefined && state.pointerId !== pointerId && !state.dragging) {
          return;
        }

        clearDesktopDragHoldTimer();
        state.desktopDragArmed = false;
        if (state.dragging || state.dragExpressionIndex !== null || widget.classList.contains("dragging")) {
          if (state.moved || state.dragging) {
            state.suppressClickUntil = Date.now() + 450;
          }
          state.dragging = false;
          setDraggingVisual(false);
        }
        if (state.pointerId !== null && widget.hasPointerCapture(state.pointerId)) {
          widget.releasePointerCapture(state.pointerId);
        }
        state.desktopPointerDown = false;
        state.desktopWindowReady = false;
        state.desktopTargetX = null;
        state.desktopTargetY = null;
        state.pointerId = null;
        state.desktopAutoMoveLockUntil = Date.now() + 1200;
      }

      async function moveDesktopWindowRandomX() {
        if (state.settingsOpen || state.exiting) {
          return;
        }

        const geometry = await invokeTauri("get_window_geometry");
        const maxX = geometry.monitor_x + Math.max(0, geometry.monitor_width - geometry.width);
        const minX = geometry.monitor_x;
        const safeStartX = clamp(geometry.x, minX, maxX);
        const fixedY = clamp(
          geometry.y,
          geometry.monitor_y,
          geometry.monitor_y + Math.max(0, geometry.monitor_height - geometry.height)
        );

        let direction = Math.random() < 0.5 ? -1 : 1;
        if (safeStartX <= minX + 12) {
          direction = 1;
        } else if (safeStartX >= maxX - 12) {
          direction = -1;
        }

        const maxTravel = Math.max(40, Math.round((maxX - minX) * 0.6));
        const desiredDistance = Math.round(90 + Math.random() * maxTravel);
        const rawTargetX = safeStartX + direction * desiredDistance;
        const targetX = clamp(rawTargetX, minX, maxX);
        const totalDistance = Math.abs(targetX - safeStartX);
        setFacingByDelta(targetX - safeStartX);

        if (totalDistance < 8) {
          return;
        }

        let currentX = safeStartX;
        let stepCount = 0;
        let hop = null;
        while (Math.abs(targetX - currentX) > 0) {
          if (state.exiting || state.dragging || Date.now() < state.desktopAutoMoveLockUntil) {
            return;
          }

          const remaining = Math.abs(targetX - currentX);
          const stride = Math.min(remaining, Math.round(4 + Math.random() * 6));
          const moveSign = targetX > currentX ? 1 : -1;
          currentX = clamp(currentX + moveSign * stride, minX, maxX);

          if (!hop && Math.random() < 0.14) {
            hop = {
              frame: 0,
              totalFrames: Math.round(8 + Math.random() * 6),
              height: Math.round(8 + Math.random() * 12)
            };
          }

          let yOffset = 0;
          if (hop) {
            const phase = hop.frame / hop.totalFrames;
            yOffset = Math.round(Math.sin(phase * Math.PI) * hop.height);
            hop.frame += 1;
            if (hop.frame > hop.totalFrames) {
              hop = null;
            }
          }

          await invokeTauri("set_window_position", { x: currentX, y: fixedY - yOffset });
          stepCount += 1;

          const baseDelay = 12 + Math.random() * 10;
          await wait(Math.round(baseDelay));

          if (stepCount % 5 === 0 && Math.random() < 0.3) {
            await wait(Math.round(18 + Math.random() * 24));
          }
        }
      }

      async function startDesktopHorizontalWander() {
        while (true) {
          const nextWait = Math.round(1100 + Math.random() * 2600);
          await wait(nextWait);

          if (state.exiting || state.settingsOpen || state.dragging || Date.now() < state.desktopAutoMoveLockUntil) {
            continue;
          }

          try {
            await moveDesktopWindowRandomX();
          } catch (_error) {
            await wait(1000);
          }
        }
      }

      sprite.addEventListener("load", function () {
        widget.classList.remove("sprite-failed");
        const expression = expressions[expressionIndex];
        setGuide("Mode: " + expression.label + " (" + (expressionIndex + 1) + "/" + expressions.length + ")");
      });

      sprite.addEventListener("error", function () {
        widget.classList.add("sprite-failed");
        setGuide("Sprite load failed: " + sprite.getAttribute("src"));
      });

      widget.addEventListener("click", function () {
        if (state.exiting) {
          return;
        }
        closeSettingsPanel();
        if (state.dragging) {
          return;
        }
        if (state.moved) {
          state.moved = false;
          return;
        }
        if (Date.now() < state.suppressClickUntil) {
          return;
        }
        nextExpression(true);
      });

      widget.addEventListener("contextmenu", function (event) {
        event.preventDefault();
        if (state.dragging || state.exiting) {
          return;
        }
        openSettingsPanel(event.clientX, event.clientY);
        setGuide("Settings opened.");
      });

      if (settingsSizeRange) {
        settingsSizeRange.addEventListener("input", function () {
          const targetWidth = Number(settingsSizeRange.value);
          if (!Number.isFinite(targetWidth)) {
            return;
          }

          applyWidgetSize(targetWidth, {
            persistSize: true,
            adjustPosition: !isTauriDesktop,
            persistPosition: !isTauriDesktop
          });
        });
      }

      if (settingsPumpkinButton) {
        settingsPumpkinButton.addEventListener("click", function () {
          if (state.exiting) {
            return;
          }

          if (isTauriDesktop) {
            closeSettingsPanel();
            invokeTauri("spawn_pumpkin")
              .then(function (touchedPumpkin) {
                state.desktopAutoMoveLockUntil = Date.now() + 300000;
                if (touchedPumpkin) {
                  playVoice("I like pumpkin.WAV");
                }
              })
              .catch(function () {
                setGuide("Pumpkin spawn failed.");
              });
            return;
          }

          const popup = window.open(assetPath("images", "hobak.png"), "_blank");
          if (!popup) {
            setGuide("Popup blocked. Allow popups to show pumpkin.");
          }
          closeSettingsPanel();
        });
      }

      if (settingsExitButton) {
        settingsExitButton.addEventListener("click", function () {
          runExitSequence();
        });
      }

      document.addEventListener("pointerdown", function (event) {
        if (state.exiting || !state.settingsOpen || !settingsPanel) {
          return;
        }
        if (settingsPanel.contains(event.target)) {
          return;
        }
        closeSettingsPanel();
      });

      if (stage) {
        stage.addEventListener("pointerdown", function (event) {
          if (!state.settingsOpen || state.exiting) {
            return;
          }
          if (event.target === stage) {
            closeSettingsPanel();
          }
        });
      }

      window.addEventListener("keydown", function (event) {
        if (state.exiting) {
          return;
        }
        if (event.key === "Escape") {
          closeSettingsPanel();
        }
      });

      setExpression(0, false);
      loadWidgetSize();

      if (isTauriDesktop) {
        document.body.classList.add("desktop-widget-mode");
        setGuide("Desktop mode: drag + auto movement. Right-click for settings.");
        state.desktopAutoMoveLockUntil = Date.now() + 1500;
        startDesktopFacingTracking();

        widget.addEventListener("pointerdown", function (event) {
          if (state.exiting) {
            return;
          }
          if (state.settingsOpen) {
            closeSettingsPanel();
            return;
          }

          if (event.button !== 0 && event.pointerType !== "touch") {
            return;
          }

          if (state.dragExpressionIndex !== null || widget.classList.contains("dragging")) {
            setDraggingVisual(false);
          }
          state.dragging = false;
          state.pointerId = event.pointerId;
          state.startX = event.clientX;
          state.startY = event.clientY;
          state.desktopStartScreenX = event.screenX;
          state.desktopStartScreenY = event.screenY;
          state.moved = false;
          state.desktopPointerDown = true;
          state.desktopDragArmed = false;
          state.desktopWindowReady = false;
          state.desktopTargetX = null;
          state.desktopTargetY = null;
          state.desktopAutoMoveLockUntil = Date.now() + 4500;
          widget.setPointerCapture(event.pointerId);
          clearDesktopDragHoldTimer();

          const holdPointerId = event.pointerId;
          state.desktopDragHoldTimer = window.setTimeout(function () {
            if (!state.desktopPointerDown || state.pointerId !== holdPointerId) {
              return;
            }
            state.desktopDragArmed = true;
            state.dragging = true;
            setDraggingVisual(true);
            playDragVoice();
          }, desktopDragHoldMs);

          invokeTauri("get_window_geometry")
            .then(function (geometry) {
              if (state.pointerId !== event.pointerId || !state.desktopPointerDown) {
                return;
              }
              state.desktopWindowStartX = geometry.x;
              state.desktopWindowStartY = geometry.y;
              state.desktopWindowReady = true;
            })
            .catch(function () {
              setGuide("Window geometry fetch failed.");
            });
        });

        widget.addEventListener("pointermove", function (event) {
          if (state.exiting) {
            return;
          }
          if (state.pointerId !== event.pointerId) {
            return;
          }

          const signedDeltaX = event.screenX - state.desktopStartScreenX;
          const signedDeltaY = event.screenY - state.desktopStartScreenY;
          const deltaX = Math.abs(signedDeltaX);
          const deltaY = Math.abs(signedDeltaY);
          setFacingByDelta(signedDeltaX);
          if (!state.desktopDragArmed) {
            return;
          }

          if (!state.moved && deltaX <= 1 && deltaY <= 1) {
            return;
          }

          state.moved = true;
          state.dragging = true;
          if (!state.desktopWindowReady) {
            return;
          }

          queueDesktopWindowMove(
            Math.round(state.desktopWindowStartX + signedDeltaX),
            Math.round(state.desktopWindowStartY + signedDeltaY)
          );
        });

        function stopDesktopDrag(event) {
          if (state.exiting) {
            return;
          }
          if (state.pointerId !== event.pointerId) {
            return;
          }

          if (event.type === "pointercancel") {
            return;
          }

          state.desktopPointerDown = false;
          finishDesktopDrag(event.pointerId);
        }

        widget.addEventListener("pointerup", stopDesktopDrag);
        widget.addEventListener("pointercancel", stopDesktopDrag);
        window.addEventListener("pointerup", function () {
          state.desktopPointerDown = false;
          finishDesktopDrag();
        });
        window.addEventListener("mouseup", function () {
          state.desktopPointerDown = false;
          finishDesktopDrag();
        });
        startPumpkinEventPolling();
        startDesktopHorizontalWander();
        return;
      }

      widget.classList.add("browser-draggable");
      setGuide("Browser mode. Drag to move, click mood, right-click settings.");

      function bounds() {
        return {
          minX: margin,
          minY: margin,
          maxX: Math.max(margin, window.innerWidth - widget.offsetWidth - margin),
          maxY: Math.max(margin, window.innerHeight - widget.offsetHeight - margin)
        };
      }

      function setPosition(x, y) {
        const b = bounds();
        const safeX = clamp(x, b.minX, b.maxX);
        const safeY = clamp(y, b.minY, b.maxY);
        widget.style.left = safeX + "px";
        widget.style.top = safeY + "px";
      }

      function currentPosition() {
        return {
          x: parseFloat(widget.style.left) || 0,
          y: parseFloat(widget.style.top) || 0
        };
      }

      function savePosition() {
        localStorage.setItem(storageKey, JSON.stringify(currentPosition()));
      }

      function resetToDefault() {
        const b = bounds();
        setPosition(b.maxX, b.maxY);
        savePosition();
      }

      function loadPosition() {
        try {
          const raw = localStorage.getItem(storageKey);
          if (!raw) {
            resetToDefault();
            return;
          }

          const pos = JSON.parse(raw);
          if (typeof pos.x !== "number" || typeof pos.y !== "number") {
            resetToDefault();
            return;
          }

          setPosition(pos.x, pos.y);
        } catch (_error) {
          resetToDefault();
        }
      }

      widget.addEventListener("dragstart", function (event) {
        event.preventDefault();
      });

      widget.addEventListener("pointerdown", function (event) {
        if (state.exiting) {
          return;
        }
        if (state.settingsOpen) {
          closeSettingsPanel();
          return;
        }

        if (event.button !== 0 && event.pointerType !== "touch") {
          return;
        }

        const pos = currentPosition();
        state.dragging = true;
        state.pointerId = event.pointerId;
        state.dragOffsetX = event.clientX - pos.x;
        state.dragOffsetY = event.clientY - pos.y;
        state.startX = event.clientX;
        state.startY = event.clientY;
        state.moved = false;
        widget.setPointerCapture(event.pointerId);
      });

      widget.addEventListener("pointermove", function (event) {
        if (state.exiting) {
          return;
        }
        if (!state.dragging || state.pointerId !== event.pointerId) {
          return;
        }

        const signedDeltaX = event.clientX - state.startX;
        const deltaX = Math.abs(signedDeltaX);
        const deltaY = Math.abs(event.clientY - state.startY);
        setFacingByDelta(signedDeltaX);
        if (deltaX > 5 || deltaY > 5) {
          if (!state.moved) {
            playDragVoice();
            setDraggingVisual(true);
          }
          state.moved = true;
        }

        setPosition(event.clientX - state.dragOffsetX, event.clientY - state.dragOffsetY);
      });

      function stopDrag(event) {
        if (state.exiting) {
          return;
        }
        if (!state.dragging || state.pointerId !== event.pointerId) {
          return;
        }

        state.dragging = false;
        state.pointerId = null;
        setDraggingVisual(false);
        if (widget.hasPointerCapture(event.pointerId)) {
          widget.releasePointerCapture(event.pointerId);
        }
        if (state.moved) {
          state.suppressClickUntil = Date.now() + 150;
        }
        savePosition();
      }

      widget.addEventListener("pointerup", stopDrag);
      widget.addEventListener("pointercancel", stopDrag);
      widget.addEventListener("dblclick", resetToDefault);

      window.addEventListener("resize", function () {
        applyWidgetSize(currentWidgetWidth(), {
          persistSize: false,
          adjustPosition: false
        });
        const pos = currentPosition();
        setPosition(pos.x, pos.y);
        savePosition();
      });

      window.addEventListener("load", loadPosition);
    })();
  </script>
</body>
</html>
